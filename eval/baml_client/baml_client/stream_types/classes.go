// ----------------------------------------------------------------------------
//
//  Welcome to Baml! To use this generated code, please run the following:
//
//  $ go get github.com/boundaryml/baml
//
// ----------------------------------------------------------------------------

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ go install github.com/boundaryml/baml/baml-cli

package stream_types

import (
	"fmt"

	baml "github.com/boundaryml/baml/engine/language_client_go/pkg"
	"github.com/boundaryml/baml/engine/language_client_go/pkg/cffi"
)

type BusinessProfile struct {
	BusinessName   *string   `json:"businessName"`
	BusinessType   *string   `json:"businessType"`
	City           *string   `json:"city"`
	Neighbourhood  *string   `json:"neighbourhood"`
	Services       []Service `json:"services"`
	TargetAudience *string   `json:"targetAudience"`
	BrandVibe      *string   `json:"brandVibe"`
	Quirks         []string  `json:"quirks"`
}

func (c *BusinessProfile) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "BusinessProfile" {
		panic(fmt.Sprintf("expected BusinessProfile, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "businessName":
			c.BusinessName = baml.Decode(valueHolder).Interface().(*string)

		case "businessType":
			c.BusinessType = baml.Decode(valueHolder).Interface().(*string)

		case "city":
			c.City = baml.Decode(valueHolder).Interface().(*string)

		case "neighbourhood":
			c.Neighbourhood = baml.Decode(valueHolder).Interface().(*string)

		case "services":
			c.Services = baml.Decode(valueHolder).Interface().([]Service)

		case "targetAudience":
			c.TargetAudience = baml.Decode(valueHolder).Interface().(*string)

		case "brandVibe":
			c.BrandVibe = baml.Decode(valueHolder).Interface().(*string)

		case "quirks":
			c.Quirks = baml.Decode(valueHolder).Interface().([]string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class BusinessProfile", key))

		}
	}

}

func (c BusinessProfile) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["businessName"] = c.BusinessName

	fields["businessType"] = c.BusinessType

	fields["city"] = c.City

	fields["neighbourhood"] = c.Neighbourhood

	fields["services"] = c.Services

	fields["targetAudience"] = c.TargetAudience

	fields["brandVibe"] = c.BrandVibe

	fields["quirks"] = c.Quirks

	return baml.EncodeClass("BusinessProfile", fields, nil)
}

func (c BusinessProfile) BamlTypeName() string {
	return "BusinessProfile"
}

type JudgeResult struct {
	Reasoning *string `json:"reasoning"`
	Verdict   *bool   `json:"verdict"`
}

func (c *JudgeResult) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "JudgeResult" {
		panic(fmt.Sprintf("expected JudgeResult, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "reasoning":
			c.Reasoning = baml.Decode(valueHolder).Interface().(*string)

		case "verdict":
			c.Verdict = baml.Decode(valueHolder).Interface().(*bool)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class JudgeResult", key))

		}
	}

}

func (c JudgeResult) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["reasoning"] = c.Reasoning

	fields["verdict"] = c.Verdict

	return baml.EncodeClass("JudgeResult", fields, nil)
}

func (c JudgeResult) BamlTypeName() string {
	return "JudgeResult"
}

type Service struct {
	Name     *string  `json:"name"`
	PriceBRL *float64 `json:"priceBRL"`
}

func (c *Service) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "Service" {
		panic(fmt.Sprintf("expected Service, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "name":
			c.Name = baml.Decode(valueHolder).Interface().(*string)

		case "priceBRL":
			c.PriceBRL = baml.Decode(valueHolder).Interface().(*float64)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class Service", key))

		}
	}

}

func (c Service) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["name"] = c.Name

	fields["priceBRL"] = c.PriceBRL

	return baml.EncodeClass("Service", fields, nil)
}

func (c Service) BamlTypeName() string {
	return "Service"
}
